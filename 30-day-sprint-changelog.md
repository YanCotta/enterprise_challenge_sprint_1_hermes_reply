# 30-Day Sprint Changelog

This document records all changes made during the final 30-day sprint toward delivery.

## 2025-08-11 (Days 1–3)

- Compose: Updated `smart-maintenance-saas/docker-compose.yml`
  - Services: `api` (FastAPI), `ui` (Streamlit), `db` (TimescaleDB pg15).
  - API hardening: run `alembic upgrade head` before `uvicorn`; `restart: unless-stopped`; healthcheck `GET /health` every 30s.
  - Environment: `env_file: .env` plus `DATABASE_URL` (service-to-service host `db`), `PYTHONPATH=/app`, `DISABLE_CHROMADB=true`.
  - Volumes: mount `./logs` into container for persisted JSON logs.
  - UI: points to API via internal URL `http://api:8000`; healthcheck `GET /` on 8501; depends on API+DB health.
  - DB: `timescale/timescaledb:latest-pg15`, init script mounts `infrastructure/docker/init-scripts` to enable extension.

- Alembic migration (Timescale policies): Added `alembic_migrations/versions/20250811_120000_add_timescale_policies.py`
  - Idempotently ensures `CREATE EXTENSION IF NOT EXISTS timescaledb;`.
  - Policies on `sensor_readings` hypertable:
    - Retention: `SELECT add_retention_policy('sensor_readings', INTERVAL '180 days');`
    - Compression: `ALTER TABLE sensor_readings SET (timescaledb.compress);`
    - Compression policy: `SELECT add_compression_policy('sensor_readings', INTERVAL '7 days');`
  - Optional commented CAGG definition for 1‑minute rollups (kept off for now to reduce overhead).

- DB docs & ERD artifacts
  - ERD source: `smart-maintenance-saas/docs/db/erd.dbml` with four core entities and FK from `maintenance_logs.task_id → maintenance_tasks.id`.
  - DB README: `smart-maintenance-saas/docs/db/README.md` with entities, constraints, indexes, and Timescale policies rationale.
  - Scripts:
    - `scripts/export_schema.sh`: exports schema-only SQL via `pg_dump` to `docs/db/schema.sql` (auto-downgrades async URL for pg_dump).
    - `scripts/generate_erd.sh`: optional ERD PNG export using `eralchemy2` (requires Python+Graphviz on the host).

- Schema SQL
  - `docs/db/schema.sql` generated by running `./scripts/export_schema.sh` after the stack is up.
  - Notes: Timescale warnings about circular FKs may appear during dump; schema export still completes successfully.

## Verification performed

- Brought up stack with `docker compose up -d --build`.
- Health checks:
  - API: 200 OK on `/health` and DB connectivity verified on `/health/db`.
- Confirmed Alembic runs on API start with no errors; DB extension enabled via init script.

## 2025-08-11 (Day 4)

- Ingestion hardening:
  - Endpoint: `POST /api/v1/data/ingest` now supports `Idempotency-Key` header. In-memory TTL store (10 min) prevents duplicate event publication for the same key.
  - Structure: simple dict key → (event_id, expire_ts) with periodic cleanup; safe under a single API replica.
  - Verified behavior by issuing two identical POSTs with same `Idempotency-Key`; second response returned `"status":"duplicate_ignored"` with the original `event_id`.
- Correlation/Request IDs:
  - Added `apps/api/middleware/request_id.py`. If `X-Request-ID` is present, it’s reused; otherwise a UUIDv4 is generated.
  - Middleware sets `request.state.correlation_id` for downstream use and adds `X-Request-ID` to every response.
- Scripts portability:
  - Switched scripts to `bash` shebang and marked executable.
- ERD PNG:
  - ERD PNG generation via `eralchemy2` requires Graphviz toolchain (and build tools). Since our runtime image is slim by design, prefer manual PNG export from `docs/db/erd.dbml` using a modeling tool when needed.

## Risk review and mitigations (Days 1–4)

- Compose and migrations: Low risk. Alembic upgrade runs before serving to avoid schema drift. Health checks protect dependent services.
- Timescale policies: Low operational risk. Retention/compression choices are conservative (180d retain, compress ≥7d). Can be tuned via a new migration.
- ERD generation: Toolchain heavy; intentionally not in runtime image to avoid bloat. Keep DBML as source of truth; PNG generated externally on demand.
- Idempotency cache: In-memory per replica. For multi-replica/higher durability, swap to Redis with TTL. TTL and periodic cleanup cap memory growth.
- Request IDs: Propagate for client traceability now. For full structured logs with correlation IDs, wire `logging` extras or adopt a request-context logger in a later observability task.

## 2025-08-12 (Pre-Day 5) – Deferments for delivery focus

- Idempotency backend (Redis): Deferred. Current in-memory TTL cache is sufficient for single-replica scope. Re-evaluate post load testing if horizontal scaling is required.
- Full metrics stack (Prometheus/Grafana): Deferred until Week 3. We will prioritize only if load testing reveals performance/observability needs beyond basic health/logs.

## 2025-08-12 (Day 5) – Database Schema & TimescaleDB Migration Resolution

### Complete Troubleshooting Journey ✅

#### Initial Fix
The TimescaleDB error was resolved by modifying the migration `20250812_090000_finalize_data_model.py` to no longer DROP the `id` column from `sensor_readings`. The original error occurred because:
- TimescaleDB compression was enabled on the `sensor_readings` hypertable
- Compressed hypertables prevent DDL operations like `DROP COLUMN`
- The migration attempted to remove the `id` column to implement a composite primary key

**Solution**: Removed the `DROP COLUMN id` operation while preserving the composite primary key creation `(timestamp, sensor_id)`.

#### New Discovery
This initial fix created a new problem where the `id` column became `NOT NULL` without a `DEFAULT` value, which would break our data seeder and any INSERT operations that didn't explicitly provide an `id` value.

**Problem**: The `id` column was defined as `NOT NULL` but lacked a server-side default, causing:
- INSERT failures when no `id` value was provided
- Incompatibility with ORM models expecting auto-generated values
- Data seeding scripts unable to function properly

#### Final Resolution
A new migration was created (`20250812_150000_add_default_uuid_to_sensor_readings_id.py`) to add an auto-incrementing integer sequence to the `id` column, ensuring its value is always generated automatically. The ORM was updated to match.

**Technical Implementation**:
1. **Migration**: Created sequence `sensor_readings_id_seq` with `ALTER COLUMN id SET DEFAULT nextval('sensor_readings_id_seq')`
2. **ORM Update**: Modified `SensorReadingORM.id` from `UUID` type to `Integer` with sequence reference
3. **TimescaleDB Compatibility**: Used sequence-based approach instead of UUID conversion to avoid compression conflicts

#### Validation
The fix was validated with a successful two-part INSERT statement:
1. **Sensor Creation**: `INSERT INTO sensors (sensor_id, type, location, status) VALUES ('test-sensor-001', 'temperature', 'Zone A', 'active')`
2. **Reading Insertion**: `INSERT INTO sensor_readings (...) VALUES (...) RETURNING id, sensor_id, timestamp`
3. **Result**: Auto-generated `id=3`, confirming sequence functionality

#### Final System State
- **Migration Chain**: All 5 migrations applied successfully
- **Schema Export**: `./scripts/export_schema.sh` completed with no git diff differences
- **Health Checks**: All containers (api, db, ui) reporting healthy status
- **Data Operations**: Verified INSERT with auto-generated primary keys working correctly

**Result**: Development unblocked, Day 5 objectives can proceed with stable database foundation.

