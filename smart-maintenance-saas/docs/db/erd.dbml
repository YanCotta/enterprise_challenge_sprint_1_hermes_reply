Project smart_maintenance_saas {
  database_type: "PostgreSQL"
  Note: 'Smart Maintenance SaaS - TimescaleDB Schema (Updated 2025-08-31)'
}

// --- Enums for Data Integrity ---
Enum task_status {
  pending
  in_progress
  completed
  partially_completed
  failed
  cancelled
}

Enum alert_status {
  open
  acknowledged
  resolved
  ignored
}

Enum sensor_status {
  active
  inactive
  maintenance
  decommissioned
}

// --- Core Tables ---
Table sensors {
  id uuid [pk, default: `gen_random_uuid()`]
  sensor_id varchar(255) [unique, not null, note: 'Business identifier (e.g., sensor-001)']
  type varchar(50) [not null, note: 'temperature, vibration, pressure, humidity, voltage']
  location varchar(255) [note: 'Physical location description']
  status sensor_status [not null, default: 'active']
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
}

Table sensor_readings {
  id integer [pk, note: 'Auto-generated sequence for TimescaleDB compatibility']
  timestamp timestamptz [not null, note: 'Primary partitioning key for TimescaleDB']
  sensor_id varchar(255) [not null, note: 'Business reference to sensors table']
  sensor_type varchar(50) [not null, note: 'Denormalized for query performance']
  value float8 [not null, note: 'Sensor measurement value']
  unit varchar(50) [note: 'Measurement unit (Â°C, Hz, PSI, etc.)']
  quality float [default: 1.0, note: 'Data quality score (0.0-1.0)']
  sensor_metadata jsonb [note: 'Additional sensor context and metadata']
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
  
  indexes {
    (sensor_id, timestamp) [name: 'ix_sensor_readings_sensor_timestamp']
    (timestamp, sensor_id) [pk, name: 'sensor_readings_pkey']
  }
}

Table anomaly_alerts {
  id uuid [pk, default: `gen_random_uuid()`]
  sensor_id varchar(255) [not null, note: 'References sensors.sensor_id']
  anomaly_type varchar(100) [not null, note: 'Type of anomaly detected']
  severity integer [not null, note: '1=Low, 2=Medium, 3=High, 4=Critical, 5=Emergency']
  confidence float [note: 'ML model confidence score (0.0-1.0)']
  description text [note: 'Human-readable anomaly description']
  evidence jsonb [note: 'ML evidence and supporting data']
  recommended_actions text[] [note: 'Array of recommended actions']
  status alert_status [not null, default: 'open']
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
}

Table maintenance_tasks {
  id uuid [pk, default: `gen_random_uuid()`]
  equipment_id varchar(255) [not null, note: 'Equipment/sensor identifier']
  task_type varchar(100) [not null, note: 'Type of maintenance task']
  description text [note: 'Detailed task description']
  priority integer [not null, default: 3, note: '1=High, 2=Medium, 3=Low, 4=Deferred, 5=Optional']
  status task_status [not null, default: 'pending']
  estimated_duration_hours float [note: 'Estimated time to complete']
  actual_duration_hours float [note: 'Actual time taken']
  required_skills text[] [note: 'Required technician skills']
  parts_needed text[] [note: 'Required parts and materials']
  assigned_technician_id varchar(255) [note: 'Assigned technician identifier']
  scheduled_start_time timestamptz [note: 'Planned start time']
  scheduled_end_time timestamptz [note: 'Planned completion time']
  actual_start_time timestamptz [note: 'Actual start time']
  actual_end_time timestamptz [note: 'Actual completion time']
  notes text [note: 'Additional task notes']
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
}

Table maintenance_logs {
  id uuid [pk, default: `gen_random_uuid()`]
  task_id uuid [not null, note: 'References maintenance_tasks.id']
  equipment_id varchar(255) [not null, note: 'Equipment/sensor identifier']
  completion_date timestamptz [not null, note: 'When maintenance was completed']
  technician_id varchar(255) [not null, note: 'Technician who performed the work']
  notes text [note: 'Maintenance work notes and observations']
  status task_status [not null, default: 'completed']
  actual_duration_hours float [note: 'Time spent on maintenance']
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
}

Table sensor_readings_summary_hourly {
  sensor_id varchar(255) [not null]
  hour timestamptz [not null, note: 'Time bucket (1 hour intervals)']
  avg_value float8 [note: 'Average sensor value for the hour']
  min_value float8 [note: 'Minimum sensor value for the hour']
  max_value float8 [note: 'Maximum sensor value for the hour']
  reading_count bigint [note: 'Number of readings in the hour']
}

// --- Relationships ---
Ref: sensor_readings.sensor_id > sensors.sensor_id
Ref: anomaly_alerts.sensor_id > sensors.sensor_id
Ref: maintenance_tasks.equipment_id > sensors.sensor_id
Ref: maintenance_logs.task_id > maintenance_tasks.id

// --- Table Notes ---
Note sensors_note {
  'Central registry for all sensor assets with lifecycle management'
}

Note sensor_readings_note {
  'TimescaleDB hypertable for high-volume time-series data with compression policies. Features composite index (sensor_id, timestamp DESC) for ML queries with sub-millisecond performance.'
}

Note anomaly_alerts_note {
  'ML-generated anomaly detection events with severity classification and confidence scoring'
}

Note maintenance_tasks_note {
  'Maintenance task management with scheduling and resource tracking'
}

Note maintenance_logs_note {
  'Immutable log of completed maintenance activities for audit and analysis'
}

Note cagg_note {
  'Continuous Aggregate (CAGG) - Pre-computed hourly statistics providing 37.3% performance improvement for dashboard queries'
}

Note performance_optimizations {
  'TimescaleDB Performance Features: Hypertable partitioning, composite indexing, automated compression (90%+ space savings), retention policies (180 days), and continuous aggregates for real-time analytics'
}